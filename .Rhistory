plot_ly() %>%
add_trace(data = filter(To_Plot, Flag == 1),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers") %>%
add_trace(data = filter(To_Plot, Flag == 0),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers")
To_TSNE <- na.omit(Data[Data$school_start_cal_year == 2014, 6:38])
To_TSNE
plot_ly() %>%
add_trace(data = filter(To_Plot, Flag == 1),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers") %>%
add_trace(data = filter(To_Plot, Flag == 0),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers")
plot_ly() %>%
add_trace(data = filter(To_Plot, Repeat == 1),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers") %>%
add_trace(data = filter(To_Plot, Repeat == 0),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers")
plot_ly() %>%
add_trace(data = filter(To_Plot, Rep == 1),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers") %>%
add_trace(data = filter(To_Plot, Rep == 0),
x = ~x,
y = ~y,
type = "scatter",
mode = "markers")
devtools::install_github('IRkernel/IRkernel')
IRkernel::installspec()
devtools::install_local('IRkernel-master.tar.gz')
IRkernel::installspec()
q()
?by
by(data = id, FUN = month = seq(from = 1, to = 12, by = 1))
by(data = id, FUN = seq(from = 1, to = 12, by = 1))
id <- c(10, 11, 12)
months <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ,12)
by(data = id, FUN = seq(from = 1, to = 12, by = 1))
by(data = id, FUN = seq(from = 1, to = 12, by = 1), INDICES = id)
id <- as.data.frame(id = seq(from = 10, to = 1000, by = 100), amount = rnorm(n = 10, mean = 10, sd = 15))
id <- data.frame(id = seq(from = 10, to = 1000, by = 100), amount = rnorm(n = 10, mean = 10, sd = 15))
id
months <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ,12)
by(data = id, INDICES = id$id, FUN = seq(from = 1, to = 12, by = 1))
by(data = id, INDICES = id$id, seq(from = 1, to = 12, by = 1))
seq(from = 1, to = 12, by = 1)
?with
id
dcast(id, id ~ amount)
library("reshape2")
dcast(id, id ~ amount)
dcast(id, id ~ month)
dcast(id, id ~ months)
data.frame(pivot <- dcast(id, id ~ months))
id <- data.frame(id = seq(10, 20, 30, 10, 40, 60, 70, 30, 40, 10),
month_trx = c(1, 4, 3, 6, 8, 4, 2, 7, 10, 11),
amount = rnorm(n = 10, mean = 10, sd = 15))
id <- data.frame(id = c(10, 20, 30, 10, 40, 60, 70, 30, 40, 10),
month_trx = c(1, 4, 3, 6, 8, 4, 2, 7, 10, 11),
amount = rnorm(n = 10, mean = 10, sd = 15))
id
id %>%
arrange(month_trx)
library("reshape2")
library("dplyr")
id %>%
arrange(month_trx)
id %>%
arrange(id, month_trx)
data.frame(pivot <- dcast(id, id ~ month_trx))
id <- data.frame(id = c(10, 20, 30, 10, 40, 60, 70, 30, 40, 10, 40, 50, 20, 10, 30, 50),
month_trx = c(1, 4, 3, 6, 8, 4, 2, 7, 10, 11, 12, 5, 9, 2, 3),
amount = rnorm(n = 16, mean = 10, sd = 15))
id <- data.frame(id = c(10, 20, 30, 10, 40, 60, 70, 30, 40, 10, 40, 50, 20, 10, 30, 50),
month_trx = c(1, 4, 3, 6, 8, 4, 2, 7, 10, 11, 12, 5, 9, 2, 3, 1),
amount = rnorm(n = 16, mean = 10, sd = 15))
id %>%
arrange(id, month_trx)
data.frame(pivot <- dcast(id, id ~ month_trx))
id <- data.frame(id = c(10, 20, 30, 10, 40, 60, 70, 30, 40, 10, 40, 50, 20, 10, 30, 50),
month_trx = c(1, 4, 3, 6, 8, 4, 2, 7, 10, 11, 13, 5, 9, 2, 3, 1),
amount = rnorm(n = 16, mean = 10, sd = 15))
arrange(id, month_trx
a <- data.frame(pivot <- dcast(id, id ~ month_trx))
a
a <- data.frame(pivot <- dcast(id, id ~ month_trx))
a
names(a) <- seq(from = 1, to = 12, by = 1)
a
names(a) <- c("id", seq(from = 1, to = 12, by = 1))
a
a %>%
mutate(d_1 = ifelse(`1` == 0, 0, 1))
library("keras")
install.packages("keras")
library("tensorflow")
library("keras")
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
x_test <- mnist$test$x
y_test <- mnist$test$y
x_train
x_train <- array_reshape(x_train, c(nrow(x_train), 784))
x_test <- array_reshape(x_test, c(nrow(x_test), 784))
# rescale
x_train <- x_train / 255
x_test <- x_test / 255
x_train
y_train <- to_categorical(y_train, 10)
y_test <- to_categorical(y_test, 10)
model <- keras_model_sequential()
model %>%
layer_dense(units = 256, activation = 'relu', input_shape = c(784)) %>%
layer_dropout(rate = 0.4) %>%
layer_dense(units = 128, activation = 'relu') %>%
layer_dropout(rate = 0.3) %>%
layer_dense(units = 10, activation = 'softmax')
summary(model)
model %>% compile(
loss = 'categorical_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy')
)
history <- model %>% fit(
x_train, y_train,
epochs = 30, batch_size = 128,
validation_split = 0.2
)
plot(history)
model %>%
evaluate(x_test, y_test)
model %>%
predict_classes(x_test)
library("dplyr")
path <- "/Volumes/Macintosh HD 1/BackUp/JorgeQuintana/Documents/Globant/Vanilla_Model"
setwd(path)
getwd()
rm(list = ls())
path <- "/Volumes/Macintosh HD 1/BackUp/JorgeQuintana/Documents/Globant/Vanilla_Model"
setwd(path)
load("d.RData")
fml = "EnrolledFollowingCountDay~SchoolGroup+GradeBand+Frl+PersistenceCode+AvgActMinsPerDay_28BeforeCountDay+
AvgBbcMinsPerDay_28BeforeCountDay+CourseMthCnt_CountDay+FailingMthCnt_CountDay+
CourseElaCnt_CountDay+FailingElaCnt_CountDay+AvgBbcMinsPerDay_28BeforeCountDay_Missing+
AvgActMinsPerDay_28BeforeCountDay_Missing"
fit = glm(as.formula(fml),d,family = binomial())
summary(fit)
fml = formula("EnrolledFollowingCountDay ~ SchoolGroup + GradeBand+Frl + PersistenceCode + AvgActMinsPerDay_28BeforeCountDay +
AvgBbcMinsPerDay_28BeforeCountDay + CourseMthCnt_CountDay + FailingMthCnt_CountDay +
CourseElaCnt_CountDay + FailingElaCnt_CountDay + AvgBbcMinsPerDay_28BeforeCountDay_Missing +
AvgActMinsPerDay_28BeforeCountDay_Missing")
fit = glm(fml, d, family = binomial())
set.seed(1234)
library("lime")
install.packages("lime")
library("lime")
library("dplyr")
library("keras")
library("lime")
library("caret")
index <- createDataPartition(y = d$EnrolledFollowingCountDay, p = 0.7)
index
X_train <- d[index, ]
X_test <- [-index, ]
X_train <- d[index, ]
X_test <- d[-index, ]
index <- createDataPartition(y = d$EnrolledFollowingCountDay, p = 0.7)
X_train <- d[index, ]
index
d[index, ]
d
d$EnrolledFollowingCountDay
d[index, ]
index <- createDataPartition(y = d$EnrolledFollowingCountDay, p = 0.7, list = FALSE)
X_train <- d[index, ]
X_test <- d[-index, ]
X_train
propt.table(table(X_train))
prop.table(table(X_train))
prop.table(table(X_train$EnrolledFollowingCountDay))
prop.table(table(X_test$EnrolledFollowingCountDay))
Train <- d[index, ]
Test <- d[-index, ]
fml = formula("EnrolledFollowingCountDay ~ SchoolGroup + GradeBand+Frl + PersistenceCode + AvgActMinsPerDay_28BeforeCountDay +
AvgBbcMinsPerDay_28BeforeCountDay + CourseMthCnt_CountDay + FailingMthCnt_CountDay +
CourseElaCnt_CountDay + FailingElaCnt_CountDay + AvgBbcMinsPerDay_28BeforeCountDay_Missing +
AvgActMinsPerDay_28BeforeCountDay_Missing")
## Logistic Regresion
fit = glm(formula = fml, data = Training, family = binomial())
## Logistic Regresion
fit = glm(formula = fml, data = Train, family = binomial())
summary(fit)
## Logistic Regresion
logit_fit = glm(formula = fml, data = Train, family = binomial())
summary(logit_fit)
predict_logit <- predict(object = logit_fit, newdata = Test, type = "response")
prop.table(table(Predict = predict_logit, Real = Test$EnrolledFollowingCountDay))
predict_logit <- predict(object = logit_fit, newdata = Test, type = 'response')
prop.table(table(Predict = predict_logit > 0.5, Real = Test$EnrolledFollowingCountDay))
Train[, -c("EnrolledFollowingCountDay")]
Train[, -c("EnrolledFollowingCountDay")]
Train[, !c("EnrolledFollowingCountDay")]
Train[, ~c("EnrolledFollowingCountDay")]
X_train <- d[index, -"EnrolledFollowingCountDay"]
X_train <- d[index, -c("EnrolledFollowingCountDay")]
X_train <- d[index, -which(names(Train) == "EnrolledFollowingCountDay")]
X_test <- d[-index, -which(names(Train) == "EnrolledFollowingCountDay")]
Y_test <- d[-index, which(names(Train) == "EnrolledFollowingCountDay")]
fml = formula("EnrolledFollowingCountDay ~ SchoolGroup + GradeBand+Frl + PersistenceCode + AvgActMinsPerDay_28BeforeCountDay +
AvgBbcMinsPerDay_28BeforeCountDay + CourseMthCnt_CountDay + FailingMthCnt_CountDay +
CourseElaCnt_CountDay + FailingElaCnt_CountDay + AvgBbcMinsPerDay_28BeforeCountDay_Missing +
AvgActMinsPerDay_28BeforeCountDay_Missing")
## Logistic Regresion
logit_fit = glm(formula = fml, data = c(X_train, Y_train), family = binomial())
Y_train <- d[index, which(names(Train) == "EnrolledFollowingCountDay")]
X_test <- d[-index, -which(names(Train) == "EnrolledFollowingCountDay")]
Y_test <- d[-index, which(names(Train) == "EnrolledFollowingCountDay")]
fml = formula("EnrolledFollowingCountDay ~ SchoolGroup + GradeBand+Frl + PersistenceCode + AvgActMinsPerDay_28BeforeCountDay +
AvgBbcMinsPerDay_28BeforeCountDay + CourseMthCnt_CountDay + FailingMthCnt_CountDay +
CourseElaCnt_CountDay + FailingElaCnt_CountDay + AvgBbcMinsPerDay_28BeforeCountDay_Missing +
AvgActMinsPerDay_28BeforeCountDay_Missing")
## Logistic Regresion
logit_fit = glm(formula = fml, data = c(X_train, Y_train), family = binomial())
Y_train
X_train
X_train <- data.frame(d[index, -which(names(Train) == "EnrolledFollowingCountDay")])
Y_train <- data.frame(d[index, which(names(Train) == "EnrolledFollowingCountDay")])
X_test <- data.frame(d[-index, -which(names(Train) == "EnrolledFollowingCountDay")])
Y_test <- data.frame(d[-index, which(names(Train) == "EnrolledFollowingCountDay")])
Y_train
heda(Y_train)
head(Y_train)
X_train <- data.frame(d[index, -which(names(Train) == "EnrolledFollowingCountDay")])
Y_train <- data.frame(EnrolledFollowingCountDay = d[index, which(names(Train) == "EnrolledFollowingCountDay")])
X_test <- data.frame(d[-index, -which(names(Train) == "EnrolledFollowingCountDay")])
Y_test <- data.frame(EnrolledFollowingCountDay = d[-index, which(names(Train) == "EnrolledFollowingCountDay")])
head(Y_train)
fml = formula("EnrolledFollowingCountDay ~ SchoolGroup + GradeBand+Frl + PersistenceCode + AvgActMinsPerDay_28BeforeCountDay +
AvgBbcMinsPerDay_28BeforeCountDay + CourseMthCnt_CountDay + FailingMthCnt_CountDay +
CourseElaCnt_CountDay + FailingElaCnt_CountDay + AvgBbcMinsPerDay_28BeforeCountDay_Missing +
AvgActMinsPerDay_28BeforeCountDay_Missing")
## Logistic Regresion
logit_fit = glm(formula = fml, data = c(X_train, Y_train), family = binomial())
summary(logit_fit)
predict_logit <- predict(object = logit_fit, newdata = X_test, type = 'response')
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test))
predict_logit <- predict(object = logit_fit, newdata = X_test, type = 'response')
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test))
nrow(Y_test)
nrow(X_test)
nrow(predict_logit)
predict_logit <- predict(object = logit_fit, newdata = X_test, type = 'response')
nrow(predict_logit)
predict_logit <- predict(object = logit_fit, newdata = X_test, type = 'response')
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test))
predict_logit <- data.frame(predict = predict(object = logit_fit, newdata = X_test, type = 'response'))
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test))
predict_logit
predict_logit
nrow(predict_logit)
nrow(Y_test)
nrow(predict_logit > 0.5)
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test))
table(Predict = predict_logit > 0.5, Real = Y_test)
table(Predict = predict_logit > 0.5, Real = Y_test)
head(Y_train)
head(predict_logit)
nrow(Y_train)
nrow(Y_test)
nrow(predict_logit)
predict_logit <- data.frame(Predict = predict(object = logit_fit, newdata = X_test, type = 'response'))
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test))
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test$EnrolledFollowingCountDay))
predict_logit <- predict(object = logit_fit, newdata = X_test, type = 'response')
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test$EnrolledFollowingCountDay))
## Random Forest
rf_fit <- train(X_train, Y_train, method = 'rf')
## Random Forest
rf_fit <- train(X_train, Y_train$EnrolledFollowingCountDay, method = 'rf')
## Random Forest
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10)
gbmFit1 <- train(fml,
data = c(X_train, Y_train),
method = "gbm",
trControl = fitControl,
verbose = FALSE)
gbmFit1 <- train(fml,
data = c(X_train, Y_train),
method = "rf",
trControl = fitControl,
verbose = FALSE)
X_train <- data.frame(d[index, -which(names(Train) == "EnrolledFollowingCountDay")])
Y_train <- data.frame(as.factor(EnrolledFollowingCountDay = d[index, which(names(Train) == "EnrolledFollowingCountDay")]))
X_test <- data.frame(d[-index, -which(names(Train) == "EnrolledFollowingCountDay")])
Y_test <- data.frame(as.factor(EnrolledFollowingCountDay = d[-index, which(names(Train) == "EnrolledFollowingCountDay")]))
Y_train <- data.frame(EnrolledFollowingCountDay = as.factor(d[index, which(names(Train) == "EnrolledFollowingCountDay")]))
Y_test <- data.frame(EnrolledFollowingCountDay = as.factor(d[-index, which(names(Train) == "EnrolledFollowingCountDay")]))
## Logistic Regresion
logit_fit = glm(formula = fml, data = c(X_train, Y_train), family = binomial())
summary(logit_fit)
predict_logit <- predict(object = logit_fit, newdata = X_test, type = 'response')
prop.table(table(Predict = predict_logit > 0.5, Real = Y_test$EnrolledFollowingCountDay))
## Random Forest
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10)
gbmFit1 <- train(fml,
data = c(X_train, Y_train),
method = "rf",
trControl = fitControl,
verbose = FALSE)
rf_fit <- train(fml,
data = c(X_train, Y_train),
method = "rf",
trControl = fitControl,
verbose = TRUE)
rf_fit <- train(fml,
data = c(X_train, Y_train$EnrolledFollowingCountDay),
method = "rf",
trControl = fitControl,
verbose = TRUE)
c(X_train, Y_train$EnrolledFollowingCountDay)
rf_fit <- train(fml,
data = cbind(X_train, Y_train),
method = "rf",
trControl = fitControl,
verbose = TRUE)
cbind(X_train, Y_train)
rf_fit <- train(fml,
data = cbind(X_train, Y_train),
method = "rf",
trControl = fitControl,
verbose = TRUE)
## Data Transformation Process
X_train <- scale(x = X_train, center = TRUE, scale = TRUE)
X_train
library("dplyr")
library("keras")
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
x_test <- mnist$test$x
y_test <- mnist$test$y
x_train <- array_reshape(x_train, c(nrow(x_train), 784))
x_test <- array_reshape(x_test, c(nrow(x_test), 784))
# rescale
x_train <- x_train / 255
x_test <- x_test / 255
y_train <- to_categorical(y_train, 10)
y_test <- to_categorical(y_test, 10)
model <- keras_model_sequential()
model %>%
layer_dense(units = 256, activation = 'relu', input_shape = c(784)) %>%
layer_dropout(rate = 0.4) %>%
layer_dense(units = 128, activation = 'relu') %>%
layer_dropout(rate = 0.3) %>%
layer_dense(units = 10, activation = 'softmax')
summary(model)
model %>% compile(
loss = 'categorical_crossentropy',
optimizer = optimizer_rmsprop(),
metrics = c('accuracy')
)
history <- model %>%
fit(x_train,
y_train,
epochs = 30,
batch_size = 128,
validation_split = 0.2)
plot(history)
model %>%
evaluate(x_test, y_test)
model %>%
predict_classes(x_test)
explainer <- lime(x_train, model)
x_train
shiny::runApp('Documents/Vanilla_Model/Vanilla_Model')
?lines
shiny::runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
shiny::runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
runApp('Documents/Vanilla_Model/Vanilla_Model')
setwd("~/Documents/GitHub/Bets")
setwd("~/")
setwd("~/Documents/GitHub/Bets")
shiny::runApp()
runApp()
Consulta <- function(Query, Table)
{
library("RPostgreSQL")
library("digest")
tryCatch(
{
drv <- dbDriver("PostgreSQL")
MyConnection <- dbConnect(drv,
dbname = "bets",
host = "localhost",
port = 5432,
user = "postgres",
password = "J0RG3qu1nt@n@")
if (dbExistsTable(MyConnection, Table))
{
Data <- dbGetQuery(conn = MyConnection, statement = Query)
}
dbDisconnect(MyConnection)
return(Data)
}, error = function(e) {print("Error al conectarse con la base de datos.")}
)
}
passwordData <- Consulta(Query = "SELECT * FROM contrasenas", Table = "contrasenas")
dbExistsTable(MyConnection, Table)
drv <- dbDriver("PostgreSQL")
MyConnection <- dbConnect(drv,
dbname = "bets",
host = "localhost",
port = 5432,
user = "postgres",
password = "J0RG3qu1nt@n@")
runApp()
rm(list = ls())
library("shinydashboard")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
unique(Data[Data$Region == input$region, "Country_Name"])
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
